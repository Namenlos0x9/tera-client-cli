'use strict'

const log = require('log'),
	fs = require('fs'),
	path = require('path'),
	enumParser = require('protojs/enum'),
	defParser = require('protojs/def'),
	ProtoTera = require('./proto/tera')

const teraData = path.dirname(require.resolve('tera-data')),
	defDir = path.join(teraData, 'protocol')

class TeraProtocol {
	constructor(shareRevision) {
		this.shareRevision = shareRevision

		const rev = require('tera-data/revisions')[shareRevision]
		if(!rev) throw Error(`Entry for protocol ${shareRevision} not found in tera-data/revisions.json`)

		this.parseRevision(rev)

		let file
		file = `map/protocol.${this.shareRevision}.map`
		try {
			this.packetEnum = enumParser(fs.readFileSync(path.join(teraData, file), 'utf8'))
		}
		catch(e) {
			if(e.code === 'ENOENT') throw Error(`${file} not found`)
			e.message = `Error reading ${file}: ${e.message}`
		}

		file = `map/sysmsg.${this.sysmsgVersion || this.majorPatchVersion}.map`
		try {
			this.sysmsgEnum = enumParser(fs.readFileSync(path.join(teraData, file), 'utf8'))
		}
		catch(e) {
			if(e.code === 'ENOENT') throw Error(`${file} not found`)
			e.message = `Error reading ${file}: ${e.message}`
		}

		if(this.majorPatchVersion >= 92) {
			file = `integrity/${this.majorPatchVersion}.json`
			try {
				const integrity = JSON.parse(fs.readFileSync(path.join(teraData, file), 'utf8'))
				this.integrityName = new Set(integrity)
				this.integrityCode = new Set(
					integrity
					.map(name => this.packetEnum.name.get(name))
					.filter(code => code !== undefined)
					.sort()
				)
			}
			catch(e) {
				if(e.code === 'ENOENT') throw Error(`${file} not found`)
				e.message = `Error parsing ${file}: ${e.message}`
			}
		}

		this.proto = new ProtoTera(this.gameVersion)
		this.packetsByName = new Map()
		this.packetsById = new Map()
	}

	parseRevision(rev) {
		// (region-)majorPatchVersion(.minorPatchVersion)(/sysmsgVersion)
		const match = /^((.+?)-)?(\d+)(\.(\d+))?(\/(\d+))?$/.exec(rev)

		if(!match) throw Error(`Invalid revision "${rev}"`)

		this.region = match[2]
		this.majorPatchVersion = Number(match[3])
		this.minorPatchVersion = Number(match[5]) || 0
		this.gameVersion = this.majorPatchVersion + this.minorPatchVersion/100
		this.sysmsgVersion = match[7] ? Number(match[7]) : undefined
	}

	compileProto(str) {
		return defParser.compile(defParser.parse(str), this.proto)
	}

	getProto(name, version) {
		// Lookup by name+version
		let compiled = this.packetsByName.get(name)
		if(compiled) compiled = compiled.get(version)

		if(!compiled) {
			compiled = defParser.compile(TeraProtocol.defs.get(name).get(def), this.proto)

			// Cache by name+version
			if(!this.packetsByName.has(name)) this.packetsByName.set(name, new Map())
			this.packetsByName.get(name).set(version, compiled)

			// If opcode is mapped: Cache by ID
			const code = this.packetEnum.name.get(name)
			if(code !== undefined) this.packetsById.set(code | version << 16, compiled)
		}

		return compiled
	}

	getIntegrity(name) { return (typeof name === 'number' ? this.integrityCode : this.integrityName)?.has(name) }

	headerLength(name) { return this.getIntegrity(name) ? 12 : 4 }

	// name|code, def|version, buf
	read(name, def, buf) {
		try {
			if(def === '*') { // Deprecated: Latest version
				const tempName = typeof name === 'number' ? this.packetEnum.code.get(name) : name
				def = Math.max(...TeraProtocol.defs.get(tempName).keys())
			}

			if(typeof def === 'number') { // version
				let compiled

				if(typeof name === 'number') { // code
					const code = name,
						id = code | def << 16

					// Lookup by ID (code+version)
					compiled = this.packetsById.get(id)
					if(!compiled) {
						name = this.packetEnum.code.get(code)

						compiled = defParser.compile(TeraProtocol.defs.get(name).get(def), this.proto)

						// Cache by name+version
						if(!this.packetsByName.has(name)) this.packetsByName.set(name, new Map())
						this.packetsByName.get(name).set(def, compiled)

						// Cache by ID
						this.packetsById.set(id, compiled)
					}
				}
				else { // name
					// Lookup by name+version
					compiled = this.packetsByName.get(name)
					if(compiled) compiled = compiled.get(def)

					if(!compiled) {
						compiled = defParser.compile(TeraProtocol.defs.get(name).get(def), this.proto)

						// Cache by name+version
						if(!this.packetsByName.has(name)) this.packetsByName.set(name, new Map())
						this.packetsByName.get(name).set(def, compiled)

						// If opcode is mapped: Cache by ID
						const code = this.packetEnum.name.get(name)
						if(code !== undefined) this.packetsById.set(code | def << 16, compiled)
					}
				}

				def = compiled
			}

			return def.read(buf, this.headerLength(name))
		}
		catch(e) {
			const name = this.packetEnum.code.get(buf.readUInt16LE(2))
			e.message = `Error parsing ${name}: ` + e.message
			throw e
		}
	}

	// name|code, def|version, val
	write(name, def, val) {
		const code = typeof name === 'number' ? name : this.packetEnum.name.get(name)

		try {
			if(def === '*') { // Deprecated: Latest version
				const tempName = typeof name === 'number' ? this.packetEnum.code.get(name) : name
				def = Math.max(...TeraProtocol.defs.get(tempName).keys())
			}

			if(typeof def === 'number') { // version
				let compiled

				if(code !== undefined) { // Mapped packet
					const id = code | def << 16

					// Lookup by ID (code+version)
					compiled = this.packetsById.get(id)
					if(!compiled) {
						if(name === code) name = this.packetEnum.code.get(code)

						compiled = defParser.compile(TeraProtocol.defs.get(name).get(def), this.proto)

						// Cache by name+version
						if(!this.packetsByName.has(name)) this.packetsByName.set(name, new Map())
						this.packetsByName.get(name).set(def, compiled)

						// Cache by ID
						this.packetsById.set(id, compiled)
					}
				}
				else { // Unmapped packet
					// Lookup by name+version
					compiled = this.packetsByName.get(name)
					if(compiled) compiled = compiled.get(def)

					if(!compiled) {
						compiled = defParser.compile(TeraProtocol.defs.get(name).get(def), this.proto)

						// Cache by name+version
						if(!this.packetsByName.has(name)) this.packetsByName.set(name, new Map())
						this.packetsByName.get(name).set(def, compiled)
					}
				}

				def = compiled
			}

			const buf = def.write(val, this.headerLength(name))
			// Write header
			buf[0] = buf.length
			buf[1] = buf.length >> 8
			buf[2] = code
			buf[3] = code >> 8
			return buf
		}
		catch(e) {
			if(name === code) name = this.packetEnum.code.get(code)
			e.message = `Error writing ${name}: ` + e.message
			throw e
		}
	}

	// name|code, def|version, val
	length(name, def, val) {
		if(def === '*') { // Deprecated: Latest version
			const tempName = typeof name === 'number' ? this.packetEnum.code.get(name) : name
			def = Math.max(...TeraProtocol.defs.get(tempName).keys())
		}

		if(typeof def === 'number') { // version
			const code = typeof name === 'number' ? name : this.packetEnum.name.get(name)

			let compiled

			if(code !== undefined) { // Mapped packet
				const id = code | def << 16

				// Lookup by ID (code+version)
				compiled = this.packetsById.get(id)
				if(!compiled) {
					if(name === code) name = this.packetEnum.code.get(code)

					compiled = defParser.compile(TeraProtocol.defs.get(name).get(def), this.proto)

					// Cache by name+version
					if(!this.packetsByName.has(name)) this.packetsByName.set(name, new Map())
					this.packetsByName.get(name).set(def, compiled)

					// Cache by ID
					this.packetsById.set(id, compiled)
				}
			}
			else { // Unmapped packet
				// Lookup by name+version
				compiled = this.packetsByName.get(name)
				if(compiled) compiled = compiled.get(def)

				if(!compiled) {
					compiled = defParser.compile(TeraProtocol.defs.get(name).get(def), this.proto)

					// Cache by name+version
					if(!this.packetsByName.has(name)) this.packetsByName.set(name, new Map())
					this.packetsByName.get(name).set(def, compiled)
				}
			}

			def = compiled
		}

		return this.headerLength(name) + def.length(val)
	}

	static loadDefs() {
		this.defs = new Map()

		for(let file of fs.readdirSync(defDir)) {
			const match = /^(.+?)\.(\d+)\.def$/.exec(file)
			if(!match) continue

			const name = match[1],
				version = Number(match[2])

			try {
				this.addDef(name, version, path.join(defDir, file))
			}
			catch(e) {
				log.error(`Error loading ${name}.${version}:`)
				log.error(e)
			}
		}

		this.versionCheck = defParser.compile(this.defs.get('C_CHECK_VERSION').get(1), new ProtoTera(0))
	}

	static addDef(name, version, file) {
		const parsed = defParser.parse(fs.readFileSync(file, 'utf8'), defDir)

		let versions = this.defs.get(name)
		if(!versions) this.defs.set(name, versions = new Map())
		versions.set(version, parsed)
	}

	static parseVersionCheck(buf) {
		return this.versionCheck.read(buf, 4)
	}
}

TeraProtocol.loadDefs()

module.exports = TeraProtocol