const log = require('log')('updater'),
	fs = require('fs'),
	path = require('path'),
	http = require('http'),
	https = require('https'),
	crypto = require('crypto'),
	zlib = require('zlib')

class Updater {
	constructor(maxSockets = 10) {
		this.httpAgent = http.Agent({keepAlive: true, maxSockets})
		this.httpsAgent = https.Agent({keepAlive: true, maxSockets})
	}

	// opts: { dir, manifestUrl, defaultUrl, compat }
	// Returns (bool) updated
	// Can throw errors
	async update(opts) {
		let localManifest, remoteManifest

		// Load local manifest
		try {
			const localManifestPath = path.join(opts.dir, 'manifest.json')
			localManifest = await callAsync(fs, 'readFile', localManifestPath, 'utf8')
			try {
				localManifest = JSON.parse(localManifest)
				if(opts.compat) localManifest = manifestFromCaali(localManifest)
			}
			catch(e) {
				log.warn(`Failed to parse ${localManifestPath}`)
				log.warn(e)
				throw e
			}
		}
		catch(e) {
			localManifest = { data: {} }
		}

		// Download remote manifest
		let res
		try {
			res = await this._httpAsync(opts.manifestUrl, localManifest.etag ? {
				headers: {
					'if-none-match': localManifest.etag,
					'accept-encoding': 'gzip'
				}
			} : null)
		}
		catch(e) {
			if(e.statusCode === 304) return false // ETag has not changed
			throw e
		}

		remoteManifest = JSON.parse(await getBody(res))
		if(opts.compat) remoteManifest = manifestFromCaali(remoteManifest)

		if(!remoteManifest.url) remoteManifest.url = opts.defaultUrl
		remoteManifest.etag = res.headers.etag

		// Check for updated files
		const filesNew = diffNew(localManifest.data, remoteManifest.data),
			filesDeleted = diffDeleted(localManifest.data, remoteManifest.data)

		if(!filesNew.length && !filesDeleted.length) {
			// There were no changes aside from ETag, so just silently update local manifest
			await callAsync(fs, 'writeFile', path.join(opts.dir, 'manifest.json'), JSON.stringify(remoteManifest))
			return false
		}

		// Download files in parallel
		const downloaded = await this.downloadFiles(remoteManifest, filesNew.filter(file => !file.endsWith('/') && file !== 'manifest.json'))
		downloaded.set('manifest.json', JSON.stringify(remoteManifest))

		// After this we do the actual update, so we need to ensure none of the files are locked beforehand
		if(await opts.preUpdate?.(new Set([...filesNew, ...filesDeleted]))) {
			await this.updateSelf(opts.dir, remoteManifest, downloaded, filesDeleted)
			return true
		}

		// Create directories
		await ensureDirs(opts.dir, filesNew)

		// Write new files / delete old ones in parallel
		const promises = new Set()

		for(let [file, data] of downloaded) promises.add(callAsync(fs, 'writeFile', path.join(opts.dir, file), data))

		for(let file of filesDeleted)
			promises.add(callAsync(fs, 'unlink', path.join(opts.dir, file)).catch(e => { if(e.code !== 'ENOENT') throw e }))

		await Promise.all(promises)

		return true
	}

	async updateSelf(dir, manifest, files, deleted) {
		// Generate temp batch script to perform actions for us
		let script = ':start'
		script += `\nstart "Waiting for application to exit" /w /min "${path.resolve(path.join(dir, 'bin/node.exe'))}" "${path.resolve(path.join(dir, 'bin/wait-for-exit'))}"`
		script += '\nif %errorlevel% NEQ 0 goto start' // Prevent broken installation if the user tries to close the window

		try {
			await callAsync(fs, 'mkdir', path.join(dir, '_update_'))
		}
		catch(e) { if(e.code !== 'EEXIST') throw e }

		const promises = new Set()
		for(let [file, data] of files) {
			// Generate temp filename from hash - Hash for manifest itself must be specifically generated here
			const tmp = path.resolve(path.join(dir, '_update_', (manifest.data[file] ?? crypto.createHash('sha256').update(data).digest('base64'))
				.replace(/\+/g, '-').replace(/\//g, '_')))

			promises.add(callAsync(fs, 'writeFile', tmp, data))
			script += `\nmove /y "${tmp}" "${path.resolve(path.join(dir, file))}"`
		}
		await Promise.all(promises)

		for(let file of deleted) script += `\ndel /f "${path.resolve(path.join(dir, file))}"`

		script += `\nrmdir /s /q "${path.resolve(path.join(dir, '_update_'))}"`
		script += '\n(goto) 2>nul & del "%~f0"' // Delete self & exit

		const scriptFile = path.resolve(path.join(dir, '_update_.cmd'))
		fs.writeFileSync(scriptFile, script)
		require('child_process').spawn('cmd', ['/q', '/d', '/c', scriptFile], { detached: true, stdio: 'ignore' })
	}

	async downloadFiles(manifest, files) {
		const promises = new Set(),
			activeRequests = new Set(),
			downloaded = new Map()

		// Simultaniously queue downloads of all files
		for(const file of files)
			promises.add((async () => {
				let url = new URL(manifest.url)
				url.pathname = url.pathname + file

				const p = this._httpAsync(url.toString())
				activeRequests.add(p.request)

				const data = await getBody(await p)
				activeRequests.delete(p.request)

				if(crypto.createHash('sha256').update(data).digest('base64') !== manifest.data[file])
					throw Error(`Downloaded file hash mismatch: ${file}`)

				downloaded.set(file, data)
			})())

		try { await Promise.all(promises) }
		catch(e) {
			for(let req of activeRequests) req.abort() // One of the files failed, so cancel the rest of our downloads
			throw e
		}

		return downloaded
	}

	// Must call this after call(s) to update() or else connections will be left hanging
	done() {
		// Actually resets the agent instead of destroying it
		this.httpAgent.destroy()
		this.httpsAgent.destroy()
	}

	_httpAsync(url, opts) {
		const isHttps = new URL(url).protocol === 'https:'

		let request
		const p = new Promise((resolve, reject) => {
			request = (!isHttps ? http : https).get(url, Object.assign({
				agent: this[!isHttps ? 'httpAgent' : 'httpsAgent'],
				headers: { 'accept-encoding': 'gzip' }
			}, opts), res => {
				if(res.statusCode !== 200) {
					res.resume() // We only care about the status code

					const err = Error(`${res.statusCode} ${res.statusMessage}: ${url}`)
					err.request = request
					err.statusCode = res.statusCode
					reject(err)
					return
				}
				resolve(res)
			})
			.setTimeout(10000)
			.on('timeout', () => {
				request.abort()

				const err = Error(`Request timed out: ${url}`)
				err.request = request
				reject(err)
			})
			.on('error', reject)
		})
		p.request = request
		return p
	}
}

function manifestFromCaali(manifest) {
	if(!manifest.files) return manifest

	manifest = {data: manifest.files}
	for(let file in manifest.data) {
		let hash = manifest.data[file]
		if(hash.hash) hash = hash.hash
		manifest.data[file] = Buffer.from(hash, 'hex').toString('base64')
	}
	return manifest
}

function diffNew(mFrom, mTo) {
	const res = []
	for(let file in mTo)
		if(mTo[file] !== mFrom[file]) res.push(file)
	return res
}

function diffDeleted(mFrom, mTo) {
	const res = []
	for(let file in mFrom)
		if(!mTo[file]) res.push(file)
	return res
}

async function ensureDirs(base, files) {
	const created = new Set()

	for(let file of files) {
		const dirs = file.split(/[\/\\]/)
		dirs.pop()
		for(let i = 1; i < dirs.length; i++) dirs[i] = dirs[i - 1] + path.sep + dirs[i]
		for(let dir of dirs)
			if(!created.has(dir)) {
				try {
					await callAsync(fs, 'mkdir', path.join(base, dir))
				}
				catch(e) { if(e.code !== 'EEXIST') throw e }

				created.add(dir)
			}
	}
}

async function getBody(res) {
	let data = await readStreamAsync(res)
	if(res.headers['content-encoding'] === 'gzip') data = await callAsync(zlib, 'gunzip', data)
	return data
}

function callAsync(lib, func, ...args) {
	return new Promise((resolve, reject) => {
		lib[func](...args, (err, rtn) => { err ? reject(err) : resolve(rtn) })
	})
}

function readStreamAsync(stream) {
	return new Promise((resolve, reject) => {
		const chunks = []
		stream
		.on('data', data => { chunks.push(data) })
		.on('end', () => { resolve(Buffer.concat(chunks)) })
		.on('error', reject)
	})
}

module.exports = Updater