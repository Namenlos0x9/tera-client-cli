#include <node.h>
#include <node_object_wrap.h>
#include "uv.h"
#include "windivert.h"

#include <iostream>

#define LOCALHOST 16777343 // 127.0.0.1 network byte order

namespace {
	using namespace std;
	using namespace v8;
	using namespace node;

	// Shorthand function
	__forceinline Local<String> NewString(Isolate* isolate, const char* data) {
		return String::NewFromUtf8(isolate, data, NewStringType::kNormal).ToLocalChecked();
	}

	struct Redirect {
		UINT addr1;
		USHORT port1;
		UINT addr2;
		USHORT port2;
		UINT ifAddr;
		UINT ifIdx;
		UINT ifSubIdx;
	};

	class ProxyGame : public ObjectWrap {
		HANDLE handle;
		WINDIVERT_ADDRESS addr;
		unsigned char packet[0xFFFF];
		UINT packetLen, errorCode = 0;
		vector<shared_ptr<Redirect>> redirects;

		ProxyGame(HANDLE h, vector<shared_ptr<Redirect>> r) {
			handle = h;
			redirects = r;
		}

		static void New(const FunctionCallbackInfo<Value>& args) {
			Isolate* isolate = args.GetIsolate();
			Local<Context> context = isolate->GetCurrentContext();

			if(!args.IsConstructCall()) {
				isolate->ThrowException(Exception::TypeError(NewString(isolate, "Constructor cannot be be invoked without \"new\"")));
				return;
			}
			if(args.Length() < 2) {
				isolate->ThrowException(Exception::TypeError(NewString(isolate, "Usage: new ProxyGame(filter, [addr1, port1, addr2, port2], ...)")));
				return;
			}

			vector<shared_ptr<Redirect>> redirects;
			redirects.reserve(args.Length() - 1);

			for(int i = 1; i < args.Length(); i++) {
				if(!args[i]->IsArray()) {
					isolate->ThrowException(Exception::TypeError(NewString(isolate, "Usage: new ProxyGame(filter, [addr1, port1, addr2, port2], ...)")));
					return;
				}

				Local<Array> arr = Local<Array>::Cast(args[i]);

				if(arr->Length() < 4) {
					isolate->ThrowException(Exception::TypeError(NewString(isolate, "Address/port array must contain at least 4 elements")));
					return;
				}

				String::Utf8Value addrStr1(isolate, arr->Get(context, 0).ToLocalChecked()), addrStr2(isolate, arr->Get(context, 2).ToLocalChecked());
				UINT addr1, addr2;

				if(!WinDivertHelperParseIPv4Address(*addrStr1, &addr1) || !WinDivertHelperParseIPv4Address(*addrStr2, &addr2)) {
					isolate->ThrowException(Exception::TypeError(NewString(isolate, "Error parsing address")));
					return;
				}

				USHORT port1 = arr->Get(context, 1).ToLocalChecked()->Uint32Value(context).ToChecked(),
					port2 = arr->Get(context, 3).ToLocalChecked()->Uint32Value(context).ToChecked();

				if(!port1 || !port2) {
					isolate->ThrowException(Exception::TypeError(NewString(isolate, "Invalid port")));
					return;
				}

				redirects.push_back(shared_ptr<Redirect>(new Redirect{
					WinDivertHelperHtonl(addr1),
					WinDivertHelperHtons(port1),
					WinDivertHelperHtonl(addr2),
					WinDivertHelperHtons(port2),
					LOCALHOST,
					1,
					0
				}));
			}

			HANDLE handle = WinDivertOpen(*String::Utf8Value(isolate, args[0]), WINDIVERT_LAYER_NETWORK, 0, 0);

			if(handle == INVALID_HANDLE_VALUE) {
				DWORD errorCode = GetLastError();
				if(errorCode == ERROR_INVALID_PARAMETER) {
					isolate->ThrowException(Exception::TypeError(NewString(isolate, "Filter syntax error")));
					return;
				}
				Local<Object> error = Local<Object>::Cast(Exception::Error(NewString(isolate, (string("Failed to open WinDivert device (") + to_string(errorCode) + ")").c_str())));
				error->DefineOwnProperty(isolate->GetCurrentContext(), NewString(isolate, "code"), Integer::New(isolate, errorCode), PropertyAttribute::DontEnum);
				isolate->ThrowException(error);
				return;
			}

			ProxyGame* me = new ProxyGame(handle, redirects);
			me->Wrap(args.This());
			args.GetReturnValue().Set(args.This());

			me->loop();
		}

		void loop() {
			uv_work_t* req = new uv_work_t;
			req->data = this;

			uv_queue_work(uv_default_loop(), req, [](uv_work_t* req) {
				((ProxyGame*)req->data)->recvAsync();
			}, [](uv_work_t* req, int status) {
				((ProxyGame*)req->data)->recvCallback();
				delete req; // TODO: Is this needed?
			});
		}

		void recvAsync() {
			if(!WinDivertRecv(handle, packet, sizeof(packet), &packetLen, &addr)) {
				errorCode = GetLastError();
				return;
			}

			PWINDIVERT_IPHDR ip;
			PWINDIVERT_TCPHDR tcp;
			WinDivertHelperParsePacket(packet, packetLen, &ip, NULL, NULL, NULL, NULL, &tcp, NULL, NULL, NULL, NULL, NULL);

			if(ip && tcp) {
				bool modified = false;

				for(auto r:redirects) {
					// Client>Server -> Client>ProxyServer
					if(ip->DstAddr == r->addr1 && tcp->DstPort == r->port1) {
						// Store WAN interface info
						r->ifAddr = ip->SrcAddr;
						r->ifIdx = addr.Network.IfIdx;
						r->ifSubIdx = addr.Network.SubIfIdx;

						ip->SrcAddr = LOCALHOST;
						ip->DstAddr = r->addr2;
						tcp->DstPort = r->port2;
						modified = true;
						break;
					}
					// ProxyServer>Client -> Server>Client
					if(ip->SrcAddr == r->addr2 && tcp->SrcPort == r->port2) {
						addr.Outbound = false;
						addr.Network.IfIdx = r->ifIdx;
						addr.Network.SubIfIdx = r->ifSubIdx;
						ip->SrcAddr = r->addr1;
						tcp->SrcPort = r->port1;
						ip->DstAddr = r->ifAddr;
						modified = true;
						break;
					}
					// ProxyClient>ProxyServer -> ProxyClient>Server
					if(ip->DstAddr == r->addr2 && tcp->DstPort == r->port2) {
						ip->SrcAddr = r->ifAddr;
						ip->DstAddr = r->addr1;
						tcp->DstPort = r->port1;
						modified = true;
						break;
					}
					// Server>Client -> Server>ProxyClient
					if(ip->SrcAddr == r->addr1 && tcp->SrcPort == r->port1) {
						addr.Outbound = true;
						ip->SrcAddr = r->addr2;
						tcp->SrcPort = r->port2;
						ip->DstAddr = LOCALHOST;
						modified = true;
						break;
					}
				}

				if(modified) WinDivertHelperCalcChecksums(packet, packetLen, &addr, 0L);
			}

			if(!WinDivertSend(handle, packet, packetLen, NULL, &addr)) errorCode = GetLastError();
		}

		void recvCallback() {
			if(errorCode) {
				if(errorCode == ERROR_OPERATION_ABORTED) return;

				Isolate* isolate = Isolate::GetCurrent();
				HandleScope scope(isolate);

				Local<Object> error = Local<Object>::Cast(Exception::Error(NewString(isolate, (string("[WinDivert] Unhandled error (") + to_string(errorCode) + ")").c_str())));
				error->DefineOwnProperty(isolate->GetCurrentContext(), NewString(isolate, "code"), Integer::New(isolate, errorCode), PropertyAttribute::DontEnum);

				TryCatch tryCatch(isolate);
				isolate->ThrowException(error);
				FatalException(isolate, tryCatch);
				return;
			}

			loop();
		}

		void close(const FunctionCallbackInfo<Value>& args) { if(handle) WinDivertClose(handle); }

	public:
		static void Init(Local<Object> exports, Local<Object> module, Local<Context> context) {
			Isolate* isolate = module->GetIsolate();

			Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
			tpl->SetClassName(NewString(isolate, "ProxyGame"));
			tpl->InstanceTemplate()->SetInternalFieldCount(1);

			NODE_SET_PROTOTYPE_METHOD(tpl, "close", [](const FunctionCallbackInfo<Value>& args) {
				ObjectWrap::Unwrap<ProxyGame>(args.Holder())->close(args);
			});

			module->Set(context, NewString(isolate, "exports"), tpl->GetFunction(context).ToLocalChecked());
		}
	};

	extern "C" NODE_MODULE_EXPORT void NODE_MODULE_INITIALIZER(Local<Object> exports, Local<Object> module, Local<Context> context) {
		ProxyGame::Init(exports, module, context);
	}
}